//================== SysCAD - Copyright Kenwalt (Pty) Ltd ===================
// $Nokeywords: $
//===========================================================================

#include "stdafx.h"
#define  __ECELL_CPP
#include "ecell.h"

//==========================================================================

/*#D:#T:ElectroCell                       
#X:#h<General Description>#N#NThe electrowinning cell converts metal in solution
into solid elemental metal.  The reaction is specified in the normal way using a RCT file.
In the dynamic mode the solids are removed separately in a batch process.  The energy 
required by the cell is calculated from the heats of reaction and the efficiency of the 
cell.  The excess energy is used to heat the contents of the unit.
#l<Connections>
The slurry flow into the cell must be connected to the feed inlet.  This must have at
least one connection, but it can have up to 20.
The overflow from the cell should be connected to the anolyte outlet. This flange has been 
configured to prevent any solids leaving with the liquid.
The removal of the metal plates is simulated by attaching a fixed mass link to the cathode
outlet.  This link must be controlled, using the general controller, to remove the cathodes 
at specified intervals.
The gas generated by the electrochemical reaction is lost to atmosphere.
#l<Metal Electrowinning>
The plated specie must be specified in the access window.
The electrowinning reactions are specified in the RB section of the model.  The method 
of writing the RCT file is found in the reactor tank documentation.
#n#h<Variables to be supplied by the user>#n
#n#i<Metal?: >The metal which is to be plated out in the electrowinning cell.  This 
variable is only required in dynamic mode, as it is used for visibility only. 
#n#i<Cell_Eff: >The efficiency of the cell. 
#n#i<Datum required :>The relative elevation of the electrowinning cell with respect to the 
common datum of the system.
#n#h<Variables calculated by the model>#n
#n#i<Cathodes: >This variable is only visible in dynamic mode.  It gives the mass 
of the plated metal in the cell.
#n#i<Energy_Reqd: >The electrical energy required to plate out the metal from the 
cell.  This includes the inefficiency of the cell.
#n#i<Datum: >The height of the electrowinning cell above the system datum.

#n#h<Other>#n
Default model prefix:EC#n
Short name:ECell#n
Model type:Unit#n
#G:Units
*/

//==========================================================================

const byte ioidFd   = 0;
const byte ioidAn   = 1;
const byte ioidCath = 2;
const byte ioidVent = 3;

static IOAreaRec ElectroCellIOAreaList[] =
  {{"Feed",      "Feed"      , ioidFd,   LIO_In ,  nc_MLnk, 1, 20, 0, 1.0f},
   {"Anolyte",   "Anolyte"   , ioidAn,   LIO_Out,  nc_MLnk, 1, 1,  0, (float)0.8},
   {"Cathodes",  "Cathodes"  , ioidCath, LIO_Out,  nc_MLnk, 1, 1,  0, 0.0f},
   {"",          "Vent"      , ioidVent, LIO_Out,  nc_MLnk, 0, 1, IOPipeEntry, 1.0f},
   SPILL2AREA("Spills", IOId_Spill2Area),
   VENT2AREA("Vents",   IOId_Vent2Area),
   {NULL}};

static double Drw_ECell[] = { DD_Poly, -10,-5, -10,5, -6,5, -6,-5, -2,-5,
                     -2,5, 2,5, 2,-5, 6,-5, 6,5, 10,5, 10,-5,
                     -10,-5, -10,5, 10,5, DD_End };  

//--------------------------------------------------------------------------

IMPLEMENT_MODELUNIT(ElectroCell, "ECell", "", Drw_ECell, "Tank", "EC", TOC_ALL|TOC_GRP_SEPAR|TOC_STD_KENWALT,
                    "Separation:Electrowinning Cell", 
                    "Electrowinning Cell removes metals "
                    "separately from the unit") 

ElectroCell::ElectroCell(pTagObjClass pClass_, pchar TagIn, pTaggedObject pAttach, TagObjAttachment eAttach) :
  MN_Surge(pClass_, TagIn, pAttach, eAttach)
  {
  AttachIOAreas(ElectroCellIOAreaList);
  Contents.SetClosed(false);
  Contents.SetPreset(&m_Preset, &m_PresetImg);
  SetAllowedModes(true, NM_All|SM_Direct|/*SM_Inline|*//*SM_Buffered|*/HM_All);

  CathMass     = 0.0;
  dCellEff     = 0.9;
  dPreHeatFrac = 0.0;//0.5;
  dHeatFlow    = 0.0;
  TempKFeed    = Std_T;
  TempKProd    = Std_T;
  iMetal       = 0;
  };

//--------------------------------------------------------------------------
/*#F:This provides access to the variables of the model and calls the
BuildDataDefn for objects used by the model.*/ 
void ElectroCell::BuildDataDefn(DataDefnBlk & DDB)
  {
  DDB.BeginStruct(this);

  DDB.Visibility(NM_Dynamic|SM_All|HM_All);
  BuildDataDefnElevation(DDB);
  DDB.Double  ("Density",       "Rho",      DC_Rho,  "kg/m^3", xidRho,         this, isResult|0);
  DDB.Double  ("Level",         "Lvl",      DC_Frac, "%",      xidLevel,       this, isResult|0);
  DDB.Double  ("Mass_Accum",    "QmAcc",    DC_Qm,   "kg/s",   &m_QmAcc,       this, isResult|0);
  DDB.Double  ("Vol_Accum",     "QvAcc",    DC_Qv,   "L/s",    &m_QvAcc,       this, isResult|0);
  DDB.Text    ("");
  DDB.Byte    ("Plated_Metal?", "Metal?",   DC_,     "",       &iMetal,        this, isParm, SDB.DDBSolSpList());
  DDB.Double  ("Cathode_Mass",  "Cathodes", DC_,     "",       &CathMass,      this, isResult|0);
  DDB.Visibility();

  DDB.Text    ("");
  DDB.Double  ("CellEfficiency","Cell_Eff", DC_Frac, "%",      &dCellEff,      this, isParm);
  //DDB.Double  ("",           "PreHeatFrac", DC_Frac, "%",      &dPreHeatFrac,  this, isParm); //possibly not needed?
  DDB.Double  ("",             "EnergyRqd", DC_Pwr,  "kW",     &dHeatFlow,     this, isResult|noFileAtAll|InitHidden);
  DDB.Double  ("",             "HeatFlow",  DC_Pwr,  "kW",     &dHeatFlow,     this, isResult|0);
  DDB.Double ("TempFeed",      "Feed.T",    DC_T,    "C",      &TempKFeed,     this, isResult);//|noFileAtAll);
  DDB.Double  ("FinalT",                "", DC_T,    "C",      &TempKProd,     this, isResult|0);

  DDB.Text    ("");
  RB.Add_OnOff(DDB);

  DDB.Text    ("");
  BuildDataDefnShowIOs(DDB, true);

  if (SolveBufferedMethod())
    RB.SetSurgeType(true); //where is the best place to set this?
  else
    RB.SetSurgeType(false);
  RB.BuildDataDefn(DDB);

  if (SolveSurgeMethod())
    {
    DDB.Object(&Contents, this, NULL, NULL, DDB_RqdPage);
    DDB.Object(&m_PresetImg, this, NULL, NULL, DDB_RqdPage);
    }

  DDB.Visibility(NM_Dynamic|SM_All|HM_All);
	//if (Contents.SpillExists())
  //  DDB.Object(&Contents.OverFlow, this, NULL, NULL, DDB_RqdPage);
  DDB.Visibility();

  DDB.EndStruct();
  };

//--------------------------------------------------------------------------

void ElectroCell::EvalJoinPressures(long JoinMask)
  {
  switch (NetMethod())
    {
    case NM_Probal:
      {
      for (int j=0; j<NoProcessJoins(); j++)
        {
        double P = PBPress();//AtmosPress(IODatum_Term(j));
        SetJoinPressure(j, P);
        }
      break;
      }
    case NM_Dynamic:
      MN_Surge::EvalJoinPressures(JoinMask);
      break;
    }
  }
 
//--------------------------------------------------------------------------
/*#F:
This determines what material should leave through each outlet,
and rate of change of the contents resulting from the flow, of material, out of each outlet
of the surge unit.
*/
void ElectroCell::EvalProducts(CNodeEvalIndex & NEI)
  {
  StkSpConduit Sd("Sd", chLINEID(), this);
  dCellEff     = Range(0.01, dCellEff, 1.0);
  dPreHeatFrac = Range(0.0, dPreHeatFrac, 1.0);

  switch (SolveMethod())
    {
    case SM_Direct:
      {
      const int iAn = IOWithId_Self(ioidAn);
      const int iCa = IOWithId_Self(ioidCath);
      SpConduit & An = *IOConduit(iAn);
      SpConduit & Ca = *IOConduit(iCa);

      SigmaQInPMin(Sd(), som_ALL, Id_2_Mask(ioidFd));
      TempKFeed = Sd().Temp();
  
      const double TotHfAtFeedT_Before = Sd().totHf(som_ALL, TempKFeed, Sd().Press());
      double emf = dHeatFlow; //use previous value
      double emfPart1 = 0.0;
      if (0)//RB() && Valid(emf) && dPreHeatFrac>0.0) possibly not needed?
        {//required to prevent low intermediate temperatures in some reactions...
        emfPart1 = emf*dPreHeatFrac;
        const double dTotHf = Sd().totHf();
        Sd().Set_totHf(dTotHf + emfPart1); //add some energy BEFORE reaction
        }

      RB.EvalProducts(Sd());
      const double TotHfAtFeedT_After = Sd().totHf(som_ALL, TempKFeed, Sd().Press());
      
      if (RB())
        {// Input energy from the electrical work applied to the cell...
        emf = TotHfAtFeedT_After - TotHfAtFeedT_Before;
        //Note: if dPreHeatFrac==0.0 then emf = (RB()->HfSumTot() * -1.0);
        emf = (emf / dCellEff);
        double emfPart2 = emf - emfPart1;
        const double dTotHf = Sd().totHf();
        Sd().Set_totHf(dTotHf + emfPart2); //add remaining energy AFTER reaction
        }
      else
        emf = 0.0;

      dHeatFlow = emf;

      double Qs = Sd().QMass(som_Sol);
      double Ql = Sd().QMass(som_Liq);
      double Qg = Sd().QMass(som_Gas);
      TempKProd = Sd().Temp();

      An.QSetM(Sd(), som_Sol, 0.0, Std_P);
      An.QAddM(Sd(), som_Liq, Ql);
    
      Ca.QSetM(Sd(), som_Sol, Qs, Std_P);
      Ca.QAddM(Sd(), som_Liq, 0.0);

      //put all vapours (if any) to vent (if present)
      const int iVent = IOWithId_Self(ioidVent);
      if (iVent>=0)
        {
        SpConduit & Cvent = *IOConduit(iVent);
        Cvent.QSetM(Sd(), som_Gas, Qg, Std_P);
        }
      else
        {
        An.QAddM(Sd(), som_Gas, Qg); //put vapours somewhere!
        }

      An.SanityCheck();
      Ca.SanityCheck();
      break;
      }
    case SM_Inline:
    case SM_Buffered:
      {
      Contents.ZeroDeriv();
      TempKFeed=Sd().Temp();
      RB.EvalProducts(Sd());

      double emf = 0.0;
      if (RB())
        {
        emf = RB()->HfSumTot();
        emf = (emf / dCellEff) * -1.0;
        Sd().Set_totHf(Sd().totHf() + emf);
        }
      dHeatFlow = emf;

      double SolMass = Contents.Mass(som_Sol);
      double LiqMass = Contents.Mass(som_Liq);
      double ETemp   = Contents.Temp();

      if (SolMass>1.0e-12 && LiqMass>1.0e-12)
        {

        // This prevents any solids leaving with the electrolyte.
        const int ioAn = IOWithId_Self(ioidAn);
        if (ioAn>=0)
          {
          SpMArray Rem;
          Rem.Set(Contents, 0.0, 1.0, 1.0);
        
          SetProdMakeup(PMU_IOId |PMU_Image, ioidAn, Rem, ETemp, Std_P, Contents.Model());
          }

        // This allows the metal and solids to leave in the metal outlet.
        // Solids other than the plated metal leave as sludge.
        const int ioCa = IOWithId_Self(ioidCath);
        if (ioCa>=0)
          {
          SpMArray Met;
          for (int j=0; j<SDB.Count(); j++)
            {
            if (SDB[j].IsSol())
              { 
              Met.SetVMass(j, Contents, Contents.VMass[j]);
              if (j == iMetal)
                CathMass = Contents.VMass[j];
              }
            else
              Met.SetVMass(j, Contents, 0.0);
            }
          SetProdMakeup(PMU_IOId |PMU_Image, ioidCath, Met, ETemp, Std_P, Contents.Model());
          }
        }
      else
        {
        // Just Operate as a Tank
        }

      SigmaQInPMin(m_QFeed, som_ALL, First64IOIds);
      EvalProducts_SurgeLevel(ContentHgtOrd, &m_QFeed);

      TempKProd=Sd().Temp();
//      if (NoProcessJoins()>=1)
//        Xfer_EvalProducts(0, Joins[0].Pressure(), NULL, &QSigmaOut, NULL, NULL, NULL);
      
      break;
      }
    }
  };

//--------------------------------------------------------------------------

void ElectroCell::ClosureInfo()
  { 
  if (m_Closure.DoFlows())
    {
    CClosureInfo &CI=m_Closure[0];
    if (RB.Enabled())
      RB.GetClosureInfo(CI);
    
    CI.m_PowerIn+=dHeatFlow;
    
    if (m_EHX.Enabled())
      CI.m_EHXPowerIn+=m_EHX.HeatFlow();
    CI.m_HfGainAtZero+=m_VLE.HfGainAtZero();
    }
  };

//===========================================================================



