//================== SysCAD - Copyright Kenwalt (Pty) Ltd ===================
// $Nokeywords: $
//===========================================================================

#include "stdafx.h"
#define  __ECELL_CPP
#include "ecell.h"

//==========================================================================

/*#D:#T:ElectroCell                       
#X:#h<General Description>#N#NThe electrowinning cell converts metal in solution
into solid elemental metal.  The reaction is specified in the normal way using a RCT file.
In the dynamic mode the solids are removed separately in a batch process.  The energy 
required by the cell is calculated from the heats of reaction and the efficiency of the 
cell.  The excess energy is used to heat the contents of the unit.
#l<Connections>
The slurry flow into the cell must be connected to the feed inlet.  This must have at
least one connection, but it can have up to 20.
The overflow from the cell should be connected to the anolyte outlet. This flange has been 
configured to prevent any solids leaving with the liquid.
The removal of the metal plates is simulated by attaching a fixed mass link to the cathode
outlet.  This link must be controlled, using the general controller, to remove the cathodes 
at specified intervals.
The gas generated by the electrochemical reaction is lost to atmosphere.
#l<Metal Electrowinning>
The plated specie must be specified in the access window.
The electrowinning reactions are specified in the RB section of the model.  The method 
of writing the RCT file is found in the reactor tank documentation.
#n#h<Variables to be supplied by the user>#n
#n#i<Metal?: >The metal which is to be plated out in the electrowinning cell.  This 
variable is only required in dynamic mode, as it is used for visibility only. 
#n#i<Cell_Eff: >The efficiency of the cell. 
#n#i<Datum required :>The relative elevation of the electrowinning cell with respect to the 
common datum of the system.
#n#h<Variables calculated by the model>#n
#n#i<Cathodes: >This variable is only visible in dynamic mode.  It gives the mass 
of the plated metal in the cell.
#n#i<Energy_Reqd: >The electrical energy required to plate out the metal from the 
cell.  This includes the inefficiency of the cell.
#n#i<Datum: >The height of the electrowinning cell above the system datum.

#n#h<Other>#n
Default model prefix:EC#n
Short name:ECell#n
Model type:Unit#n
#G:Units
*/

//==========================================================================

const byte ioidFd   = 0;
const byte ioidAn   = 1;
const byte ioidCath = 2;
const byte ioidVent = 3;

static CAltIOName AIOHood[]   = {{"Vent",   90}, {}};

static IOAreaRec ElectroCellIOAreaList[] =
  {
    {"Feed",      "Feed"      , ioidFd,   LIO_In ,  nc_MLnk, 1, 20, IOPipeEntry,                           1.0f},
    {"Anolyte",   "Anolyte"   , ioidAn,   LIO_Out,  nc_MLnk, 1, 1,  IOPipeEntry|IOSSDenied|IOChgFracHgt,   1.0f},
    {"Cathodes",  "Cathodes"  , ioidCath, LIO_Out,  nc_MLnk, 1, 1,  IOPipeEntry|IOSSDenied,                0.0f},
    {"",          "Hood"      , ioidVent, LIO_Out,  nc_MLnk, 0, 1,  IOPipeEntry|IOPassVapours,             1.05f,  {0,0,0,0}, AIOHood},
    SPILL2AREA,
    VENT2AREA(ioidVent),
    {NULL}
  };

static double Drw_ECell[] = { DD_Poly, -10,-5, -10,5, -6,5, -6,-5, -2,-5,
                     -2,5, 2,5, 2,-5, 6,-5, 6,5, 10,5, 10,-5,
                     -10,-5, -10,5, 10,5, DD_End };  

//--------------------------------------------------------------------------

IMPLEMENT_MODELUNIT(CElectroCell, "ECell", "", Drw_ECell, "Tank", "EC", TOC_ALL|TOC_GRP_SEPAR|TOC_STD_KENWALT,
                    "Separation:Electrowinning Cell", 
                    "Electrowinning Cell removes metals "
                    "separately from the unit") 

CElectroCell::CElectroCell(pTagObjClass pClass_, pchar TagIn, pTaggedObject pAttach, TagObjAttachment eAttach) :
  MN_Surge(pClass_, TagIn, pAttach, eAttach)
  {
  //m_Vent.SysEnable =  false;

  AttachIOAreas(ElectroCellIOAreaList);
  Contents.SetClosed(false);
  Contents.SetPreset(&m_Preset, &m_PresetImg);
  SetAllowedModes(true, NM_All|SM_Direct|SM_Inline|SM_Buffered|HM_All);

  CathMass           = 0.0;
  dCellEff           = 0.9;
  dPreHeatFrac       = 0.0;//0.5;
  m_dElecEnergyTotal = 0.0;
  m_dElecEnergyReact = 0.0;
  m_dElecEnergyHeat  = 0.0;
  m_TempKFeed        = Std_T;
  m_TempKProd        = Std_T;
  iMetal             = 0;
  };

//--------------------------------------------------------------------------
/*#F:This provides access to the variables of the model and calls the
BuildDataDefn for objects used by the model.*/ 
void CElectroCell::BuildDataDefn(DataDefnBlk & DDB)
  {
  DDB.BeginStruct(this);

  DDB.Visibility(NM_Dynamic|SM_All|HM_All);
  BuildDataDefnElevation(DDB);
  DDB.Double  ("Density",       "Rho",      DC_Rho,  "kg/m^3", xidRho,         this, isResult|0);
  DDB.Double  ("Level",         "Lvl",      DC_Frac, "%",      xidLevel,       this, isResult|0);
  DDB.Double  ("Mass_Accum",    "QmAcc",    DC_Qm,   "kg/s",   &m_QmAcc,       this, isResult|0);
  DDB.Double  ("Vol_Accum",     "QvAcc",    DC_Qv,   "L/s",    &m_QvAcc,       this, isResult|0);
  DDB.Text    ("");
  DDB.Byte    ("Plated_Metal?", "Metal?",   DC_,     "",       &iMetal,        this, isParm, SDB.DDBSolSpList());
  DDB.Double  ("Cathode_Mass",  "Cathodes", DC_,     "",       &CathMass,      this, isResult|0);
  DDB.Visibility();

  DDB.Text    ("");
  DDB.Double  ("CellEfficiency","Cell_Eff",        DC_Frac, "%",      &dCellEff,      this, isParm);
  //DDB.Double  ("",           "PreHeatFrac", DC_Frac, "%",      &dPreHeatFrac,  this, isParm); //possibly not needed?
  //DDB.Double  ("",             "EnergyRqd", DC_Pwr,  "kW",     &dHeatFlow,     this, isResult|noFileAtAll|InitHidden);
  //DDB.Double  ("",             "HeatFlow",  DC_Pwr,  "kW",     &dHeatFlow,     this, isResult|0);
  DDB.Double  ("",             "ElecEnergyTotal",  DC_Pwr,  "kW",     &m_dElecEnergyTotal,     this, isResult|0);
  DDB.Double  ("",             "ElecEnergyReact",  DC_Pwr,  "kW",     &m_dElecEnergyReact,     this, isResult|0);
  DDB.Double  ("",             "ElecEnergyHeat",   DC_Pwr,  "kW",     &m_dElecEnergyHeat ,     this, isResult|0);
  DDB.Text    ("");
  DDB.Double  ("TempFeed",     "Feed.T",           DC_T,    "C",      &m_TempKFeed,     this, isResult);//|noFileAtAll);
  DDB.Double  ("FinalT",       "",                 DC_T,    "C",      &m_TempKProd,     this, isResult|0);


  DDB.Text    ("");
  RB.Add_OnOff(DDB);

  DDB.Visibility();
  DDB.Text    ("");
  BuildDataDefnShowIOs(DDB, true);
  BuildDataDefnIOOpts(DDB);

  RB.BuildDataDefn(DDB);

  if (SolveSurgeMethod())
    {
    DDB.Object(&Contents, this, NULL, NULL, DDB_RqdPage);
    DDB.Object(&m_PresetImg, this, NULL, NULL, DDB_RqdPage);
    }

  DDB.Visibility(NM_Dynamic|SM_All|HM_All);
	//if (Contents.SpillExists())
  //  DDB.Object(&Contents.OverFlow, this, NULL, NULL, DDB_RqdPage);
  DDB.Visibility();

  DDB.EndStruct();
  };

//--------------------------------------------------------------------------

flag CElectroCell::ValidateData(ValidateDataBlk & VDB)
  {
  //SetIsSurgeType(SolveBufferedMethod());
  return MdlNode::ValidateData(VDB);
  }

//--------------------------------------------------------------------------

void   CElectroCell::PostConnect(int IONo)
  {
  if (IOId_Self(IONo)==ioidVent)
    m_Vent.SysEnable =  false;

  MN_Surge::PostConnect(IONo);
  };

void   CElectroCell::PreDisConnect(int IONo)
  {
  MN_Surge::PreDisConnect(IONo);

  if (IOId_Self(IONo)==ioidVent)
    m_Vent.SysEnable =  true;

  };

//--------------------------------------------------------------------------

void CElectroCell::EvalJoinPressures(long JoinMask)
  {
  switch (NetMethod())
    {
    case NM_Probal:
      {
      for (int j=0; j<NoProcessJoins(); j++)
        {
        double P = PBPress();//AtmosPress(IODatum_Term(j));
        SetJoinPressure(j, P);
        }
      break;
      }
    case NM_Dynamic:
      MN_Surge::EvalJoinPressures(JoinMask);
      break;
    }
  }
 
//--------------------------------------------------------------------------
/*#F:
This determines what material should leave through each outlet,
and rate of change of the contents resulting from the flow, of material, out of each outlet
of the surge unit.
*/
void CElectroCell::EvalProducts(CNodeEvalIndex & NEI)
  {
  StkSpConduit Sd("Sd", chLINEID(), this);
  dCellEff     = Range(0.01, dCellEff, 1.0);
  dPreHeatFrac = Range(0.0, dPreHeatFrac, 1.0);

  switch (SolveMethod())
    {
    case SM_Direct:
      {
      const int iAn = IOWithId_Self(ioidAn);
      const int iCa = IOWithId_Self(ioidCath);
      SpConduit & An = *IOConduit(iAn);
      SpConduit & Ca = *IOConduit(iCa);

      SigmaQInPMin(Sd(), som_ALL, Id_2_Mask(ioidFd));
      m_TempKFeed = Sd().Temp();
  
      const double TotHfAtFeedT_Before = Sd().totHf(som_ALL, m_TempKFeed, Sd().Press());

      RB.EvalProducts(Sd());
     
      const double TotHfAtFeedT_After = Sd().totHf(som_ALL, m_TempKFeed, Sd().Press());
      
      if (RB())
        {
        // Input energy from the electrical work applied to the cell...
        m_dElecEnergyReact = TotHfAtFeedT_After - TotHfAtFeedT_Before;
        m_dElecEnergyHeat  = (m_dElecEnergyReact/ dCellEff)-m_dElecEnergyReact;
        m_dElecEnergyTotal = m_dElecEnergyReact + m_dElecEnergyHeat;
        
        double dTotHf = Sd().totHf();
        Sd().Set_totHf(dTotHf + m_dElecEnergyTotal); //add remaining energy AFTER reaction
        }
      else
        {
        m_dElecEnergyTotal =  0.0;
        m_dElecEnergyReact =  0.0;
        m_dElecEnergyHeat  =  0.0;
        }

      double Qs = Sd().QMass(som_Sol);
      double Ql = Sd().QMass(som_Liq);
      double Qg = Sd().QMass(som_Gas);
      m_TempKProd = Sd().Temp();

      An.QSetM(Sd(), som_Sol, 0.0, Std_P);
      An.QAddM(Sd(), som_Liq, Ql);
    
      Ca.QSetM(Sd(), som_Sol, Qs, Std_P);
      Ca.QAddM(Sd(), som_Liq, 0.0);

      //put all vapours (if any) to vent (if present)
      const int iVent = IOWithId_Self(ioidVent);
      if (iVent>=0)
        {
        SpConduit & Cvent = *IOConduit(iVent);
        Cvent.QSetM(Sd(), som_Gas, Qg, Std_P);
        }
      else
        {
        An.QAddM(Sd(), som_Gas, Qg); //put vapours somewhere!
        }

      An.SanityCheck();
      Ca.SanityCheck();
      break;
      }
    case SM_Inline:
    case SM_Buffered:
      {
      Contents.ZeroDeriv();
      m_TempKFeed=Sd().Temp();
      if (SolveMethod()==SM_Inline)
        {
        RB.EvalProducts(Sd());
        }
      else
        {
        //RB.EvalDerivs(Contents, Sd(), Sd());
        }

      if (RB())
        {
        // Input energy from the electrical work applied to the cell...
        m_dElecEnergyReact = RB()->HfSumTot();
        m_dElecEnergyHeat  = (m_dElecEnergyReact/ dCellEff)-m_dElecEnergyReact;
        m_dElecEnergyTotal = m_dElecEnergyReact + m_dElecEnergyHeat;
        
        double dTotHf = Sd().totHf();
        Sd().Set_totHf(dTotHf + m_dElecEnergyTotal); //add remaining energy AFTER reaction
        }
      else
        {
        m_dElecEnergyTotal =  0.0;
        m_dElecEnergyReact =  0.0;
        m_dElecEnergyHeat  =  0.0;
        }
      //double emf = 0.0;
      //if (RB())
      //  {
      //  emf = RB()->HfSumTot();
      //  emf = (emf / dCellEff) * -1.0;
      //  Sd().Set_totHf(Sd().totHf() + emf);
      //  }
      //dHeatFlow = emf;

      double SolMass = Contents.Mass(som_Sol);
      double LiqMass = Contents.Mass(som_Liq);
      double ETemp   = Contents.Temp();

      // This prevents any solids leaving with the electrolyte.
      const int ioAn = IOWithId_Self(ioidAn);
      if (ioAn>=0)
        {
        SpMArray AnolyteFilter;
        //Rem.Set(Contents, 0.0, 1.0, 0.0);
        AnolyteFilter.SetToValue(som_Sol, 0.0);
        AnolyteFilter.SetToValue(som_Liq|som_Gas, 1.0);
        SetProdMakeup(PMU_IOId | PMU_Filter, ioidAn, AnolyteFilter, ETemp, Std_P, Contents.Model());
        }

      // This allows the metal and solids to leave in the metal outlet.
      // Solids other than the plated metal leave as sludge.
      const int ioCa = IOWithId_Self(ioidCath);
      if (ioCa>=0)
        {
        SpMArray MetalFilter;
        //Met.Set(Contents, 1.0, 0.0, 0.0);
        MetalFilter.SetToValue(som_Sol, 1.0);
        MetalFilter.SetToValue(som_Liq|som_Gas, 0.0);
        SetProdMakeup(PMU_IOId | PMU_Filter, ioidCath, MetalFilter, ETemp, Std_P, Contents.Model());
        }

      SigmaQInPMin(m_QFeed, som_ALL, First64IOIds);
      EvalProducts_SurgeLevel(SolveInlineMethod(), false, ContentHgtOrd/*, &m_QFeed*/);

      m_TempKProd=Sd().Temp();

      break;
      }
    }
  };

//--------------------------------------------------------------------------

void CElectroCell::ConvergeStates(CConvergeStateBlk &CSB)
  {
  ASSERT(NetDynamicMethod());

  if (SolveMethod()==SM_Buffered)
    {

    if (RB())
      {//only call this code if the surge is actualy used
      //#if dbgMSurge
      //if (dbgEvalConverge())
      //  dbgpln("CElectroCell::ConvergeStates - RB %s", FullObjTag());
      //#endif

      //double TempKFeed=Contents.Temp();
      double TotHfAtFeedT_Before = Contents.totHf(som_ALL, m_TempKFeed, Contents.Press());

      Contents.SetMeanResTimeCalcsReqd(true);
      RB.ConvergeStates(CSB, Contents, Contents.MeanResTimes());

      double TotHfAtFeedT_After = Contents.totHf(som_ALL, m_TempKFeed, Contents.Press());

      double emf = TotHfAtFeedT_After-TotHfAtFeedT_Before;
      emf = (emf / dCellEff);// * -1.0;
      Contents.Set_totHf(Contents.totHf() + emf);

      //#if dbgMSurge
      //if (dbgEvalConverge())
      //  dbgpln("-------------------------------------- ");
      //#endif
      };

    if (!IntegralDone() && !GetActiveHold())
      m_VLE.VFlash(Contents, 0.0, VLEF_Null);//, NULL, NULL, NULL);

    m_EqThermals.ConvergeStates(CSB);
    }
  else
    MN_Surge::ConvergeStates(CSB);
  }

//--------------------------------------------------------------------------

void CElectroCell::ClosureInfo()
  { 
  if (m_Closure.DoFlows())
    {
    CClosureInfo &CI=m_Closure[0];
    if (RB.Enabled())
      RB.GetClosureInfo(CI);
    
    CI.m_PowerIn += m_dElecEnergyTotal;
    
    if (m_EHX.Enabled())
      CI.m_EHXPowerIn+=m_EHX.HeatFlow();
    CI.m_HfGainAtZero+=m_VLE.HfGainAtZero();
    }
  };

//===========================================================================



